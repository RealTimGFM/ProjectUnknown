================================================================================
PROJECT SUMMARY
================================================================================

Generated: 2025-10-21T02:39:01Z
Root: C:\Users\User\Documents\GitHub\ProjectUnknown
Python: 3.13.5

================================================================================
PROJECT TREE
================================================================================

ProjectUnknown/
├── ats_parser/
│   ├── __init__.py
│   ├── ingest.py
│   ├── llm.py
│   ├── models.py
│   ├── parser.py
│   ├── reconcile.py
│   ├── rules.py
│   └── sections.py
├── templates/
│   ├── _flash.html
│   ├── _theme.html
│   ├── admin_candidates.html
│   ├── admin_home.html
│   ├── auth_login.html
│   ├── auth_reset_request.html
│   ├── auth_reset_set.html
│   ├── auth_signup.html
│   └── index.html
├── uploads/
│   ├── 83027bdf40824802abb5d3b488c3662e_OlivierLachanceCV_English.pdf
│   └── a70599ab4bcd458bb485b39e650fd134_QuyVuLuong_CV.pdf
├── .gitattributes
├── .gitignore
├── backend.py
├── database.db
├── dump.txt
├── dump_project.py
├── README.md
├── requirements.txt
└── resume_parser.py

Directories: 3  Files: 28

================================================================================
FILE CONTENTS
================================================================================

================================================================================
// Path: README.md
================================================================================

# Mini ATS — Structured Resume Scanner (Phase)

A minimal ATS-style web app:
- Upload a **PDF resume**.
- Backend parses sections and extracts **structured fields** (Experience, Education, Projects).
- Data is stored in **SQLite** with JSON columns.
- Web UI shows **text boxes per field**; you can edit and **save** back to DB.

---

## Features

- Section-aware parsing (SUMMARY / EXPERIENCE / EDUCATION / PROJECTS / SKILLS / LANGUAGES).
- Heuristics for dates and roles; calculates **duration (months)** when possible.
- Stores arrays (lists of dicts) as **JSON** in SQLite.
- Inline **edit & save** for each candidate.
- Safe parser (guards against missing sections / malformed bullets).

---
```powershell
## Project Structure
ProjectUnknown/
├─ backend.py # Flask app + DB CRUD
├─ resume_parser.py # PDF → structured JSON (experience/education/projects)
├─ templates/
│ └─ index.html # Upload + editable cards UI
├─ uploads/ # Saved resumes (created on first upload)
├─ database.db # SQLite (auto-created)
├─ requirements.txt
└─ README.md
## Quickstart
```

> Tested on **Python 3.13**. Works on 3.10+.

### 1) Create venv & install deps
**Windows (PowerShell):**
```powershell
python -m venv .venv
.\.venv\Scripts\Activate.ps1
pip install -r requirements.txt

python backend.py
http://127.0.0.1:5000
# stop the app, then:
del database.db         # PowerShell
# or
rm database.db          # bash/zsh
# start the app again so it recreates the table


================================================================================
// Path: backend.py
================================================================================

# backend.py — Flask upload -> parse -> save -> render
from flask import (
    Flask,
    request,
    render_template,
    jsonify,
    redirect,
    url_for,
    session,
    flash,
)
import sqlite3, os, json, uuid
from resume_parser import parse_resume
from werkzeug.utils import secure_filename
from datetime import timedelta, datetime
from werkzeug.security import generate_password_hash, check_password_hash
import secrets

# Optional pure-Python MIME sniff (no system deps). If missing, we just skip.
try:
    import filetype  # pip install filetype
except Exception:
    filetype = None

app = Flask(__name__)
app.secret_key = os.environ.get("SECRET_KEY", "dev-secret-change-me")
app.permanent_session_lifetime = timedelta(minutes=30)
IDLE_TIMEOUT_MIN = 15
DB_PATH = "database.db"
ALLOWED_EXTS = {"pdf"}
app.config["MAX_CONTENT_LENGTH"] = 10 * 1024 * 1024  # 10 MB


def allowed_file(filename: str) -> bool:
    return "." in filename and filename.rsplit(".", 1)[1].lower() in ALLOWED_EXTS


def current_user():
    uid = session.get("user_id")
    if not uid:
        return None
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT id, username, is_admin FROM users WHERE id=?", (uid,))
    row = c.fetchone()
    conn.close()
    if not row:
        return None
    return {"id": row[0], "username": row[1], "is_admin": bool(row[2])}


def login_required(fn):
    from functools import wraps

    @wraps(fn)
    def wrapper(*args, **kwargs):
        if not session.get("user_id"):
            flash("Please log in to continue.", "warn")
            return redirect(url_for("login", next=request.path))
        return fn(*args, **kwargs)

    return wrapper


def admin_required(fn):
    from functools import wraps

    @wraps(fn)
    def wrapper(*args, **kwargs):
        user = current_user()
        if not user or not user["is_admin"]:
            flash("Admin access required.", "error")
            return redirect(url_for("login"))
        return fn(*args, **kwargs)

    return wrapper


@app.before_request
def enforce_idle_timeout():
    from datetime import datetime, timezone
    now = datetime.now(timezone.utc).timestamp()
    last = session.get("last_seen")
    if session.get("user_id"):
        if last and (now - last) > (IDLE_TIMEOUT_MIN * 60):
            # idle → logout
            session.clear()
            flash("You were logged out due to inactivity.", "info")
            return redirect(url_for("login"))
        session["last_seen"] = now


@app.route("/signup", methods=["GET", "POST"])
def signup():
    if request.method == "POST":
        username = (request.form.get("username") or "").strip()
        password = request.form.get("password") or ""
        if not username or not password:
            flash("Username and password are required.", "error")
            return redirect(url_for("signup"))
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        try:
            c.execute(
                "INSERT INTO users (username, password_hash, created_at) VALUES (?,?,?)",
                (
                    username,
                    generate_password_hash(password),
                    datetime.utcnow().isoformat(),
                ),
            )
            conn.commit()
        except sqlite3.IntegrityError:
            conn.close()
            flash("Username already exists.", "error")
            return redirect(url_for("signup"))
        # Auto-login after signup
        c.execute("SELECT id FROM users WHERE username=?", (username,))
        uid = c.fetchone()[0]
        conn.close()
        session.clear()
        session.permanent = True
        session["user_id"] = uid
        from datetime import datetime, timezone
        session["last_seen"] = datetime.now(timezone.utc).timestamp()
        flash("Account created. Welcome!", "success")
        return redirect(url_for("index"))
    return render_template("auth_signup.html")


@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        username = (request.form.get("username") or "").strip()
        password = request.form.get("password") or ""
        next_url = request.args.get("next") or url_for("index")

        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute(
            "SELECT id, password_hash, is_admin FROM users WHERE username=?",
            (username,),
        )
        row = c.fetchone()
        conn.close()

        if not row or not check_password_hash(row[1], password):
            flash("Invalid username or password.", "error")
            return redirect(url_for("login", next=next_url))

        session.clear()
        session.permanent = True
        session["user_id"] = row[0]
        session["last_seen"] = datetime.utcnow().timestamp()
        flash("Logged in successfully.", "success")
        return redirect(next_url)
    return render_template("auth_login.html", next=request.args.get("next"))


@app.route("/logout")
def logout():
    session.clear()
    flash("Logged out.", "info")
    return redirect(url_for("login"))


@app.route("/reset/request", methods=["GET", "POST"])
def reset_request():
    if request.method == "POST":
        username = (request.form.get("username") or "").strip()
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute("SELECT id FROM users WHERE username=?", (username,))
        row = c.fetchone()
        if not row:
            conn.close()
            flash("If that account exists, a reset token was created.", "info")
            return redirect(url_for("reset_request"))

        uid = row[0]
        token = secrets.token_urlsafe(24)
        expires = (datetime.utcnow() + timedelta(minutes=30)).isoformat()
        c.execute(
            "INSERT INTO reset_tokens (user_id, token, expires_at) VALUES (?,?,?)",
            (uid, token, expires),
        )
        conn.commit()
        conn.close()
        # For demo: show token and direct link
        flash(f"Reset token: {token}", "info")
        flash("Use the link below within 30 minutes.", "info")
        return redirect(url_for("reset_form", token=token))
    return render_template("auth_reset_request.html")


@app.route("/reset/<token>", methods=["GET", "POST"])
def reset_form(token):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute(
        "SELECT user_id, expires_at, used FROM reset_tokens WHERE token=?", (token,)
    )
    row = c.fetchone()
    if not row:
        conn.close()
        flash("Invalid or expired token.", "error")
        return redirect(url_for("reset_request"))
    user_id, expires_at, used = row
    if used:
        conn.close()
        flash("This token was already used.", "error")
        return redirect(url_for("reset_request"))
    if datetime.utcnow() > datetime.fromisoformat(expires_at):
        conn.close()
        flash("Token expired.", "error")
        return redirect(url_for("reset_request"))

    if request.method == "POST":
        pw = request.form.get("password") or ""
        if len(pw) < 6:
            flash("Password must be at least 6 characters.", "error")
            return redirect(url_for("reset_form", token=token))
        c.execute(
            "UPDATE users SET password_hash=? WHERE id=?",
            (generate_password_hash(pw), user_id),
        )
        c.execute("UPDATE reset_tokens SET used=1 WHERE token=?", (token,))
        conn.commit()
        conn.close()
        flash("Password updated. Please log in.", "success")
        return redirect(url_for("login"))
    conn.close()
    return render_template("auth_reset_set.html", token=token)


@app.route("/admin")
@admin_required
def admin_home():
    return redirect(url_for("admin_candidates"))


@app.route("/admin/candidates")
@admin_required
def admin_candidates():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT id, name, email, phone FROM candidates ORDER BY id DESC")
    rows = c.fetchall()
    conn.close()
    return render_template("admin_candidates.html", rows=rows)


@app.post("/admin/delete/candidate/<int:cand_id>")
@admin_required
def admin_delete_candidate(cand_id: int):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("DELETE FROM candidates WHERE id=?", (cand_id,))
    conn.commit()
    conn.close()
    flash(f"Candidate #{cand_id} deleted.", "success")
    return redirect(url_for("admin_candidates"))


def init_db():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute(
        """CREATE TABLE IF NOT EXISTS candidates (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT,                     -- full display name
            first_name TEXT,
            middle_name TEXT,
            last_name TEXT,
            phone TEXT,
            email TEXT,
            links TEXT,                    -- JSON array of strings
            education TEXT,                -- JSON
            experience TEXT,               -- JSON
            projects TEXT,                 -- JSON
            skills TEXT,                   -- CSV
            languages TEXT,                -- CSV
            raw_text TEXT
        )"""
    )
    # users table
    c.execute(
        """CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT UNIQUE NOT NULL,
            password_hash TEXT NOT NULL,
            is_admin INTEGER NOT NULL DEFAULT 0,
            created_at TEXT NOT NULL
        )"""
    )
    # password reset tokens
    c.execute(
        """CREATE TABLE IF NOT EXISTS reset_tokens (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            token TEXT UNIQUE NOT NULL,
            expires_at TEXT NOT NULL,
            used INTEGER NOT NULL DEFAULT 0,
            FOREIGN KEY(user_id) REFERENCES users(id)
        )"""
    )
    conn.commit()
    # Seed a default admin once (username: admin, password: 123)
    c.execute("SELECT 1 FROM users WHERE username='admin'")
    if not c.fetchone():
        from datetime import datetime
        from werkzeug.security import generate_password_hash

        c.execute(
            "INSERT INTO users (username, password_hash, is_admin, created_at) VALUES (?,?,?,?)",
            (
                "admin",
                generate_password_hash("123"),
                1,
                datetime.utcnow().isoformat(),
            ),
        )
        conn.commit()
    conn.close()


@app.route("/", methods=["GET", "POST"])
@login_required
def index():
    if request.method == "POST":
        f = request.files.get("resume")
        if not (f and allowed_file(f.filename)):
            return render_template("index.html", candidates=[], json=json)

        os.makedirs("uploads", exist_ok=True)
        safe = secure_filename(f.filename) or "resume.pdf"
        uid = uuid.uuid4().hex
        path = os.path.join("uploads", f"{uid}_{safe}")
        f.save(path)

        # Optional lightweight MIME check (pip-only; no libmagic)
        if filetype:
            kind = filetype.guess(path)
            if not (kind and kind.mime == "application/pdf"):
                try:
                    os.remove(path)
                except Exception:
                    pass
                return render_template("index.html", candidates=[], json=json)

        parsed = parse_resume(path)

        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute(
            """INSERT INTO candidates
            (name, first_name, middle_name, last_name, phone, email, links,
                education, experience, skills, languages, raw_text)
            VALUES (?,?,?,?,?,?,?,?,?,?,?,?)""",
            (
                parsed.get("name",""),
                parsed.get("first_name", ""),
                parsed.get("middle_name", ""),
                parsed.get("last_name", ""),
                parsed.get("phone", ""),
                parsed.get("email", ""),
                json.dumps(parsed.get("links", []), ensure_ascii=False),
                json.dumps(parsed.get("education", []), ensure_ascii=False),
                json.dumps(parsed.get("experience", []), ensure_ascii=False),
                parsed.get("skills", ""),
                parsed.get("languages", ""),
                parsed.get("raw_text", ""),
            ),
        )

        conn.commit()
        conn.close()

    # fetch list
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute(
        "SELECT id, name, first_name, middle_name, last_name, phone, email, links, "
        "education, experience, skills, languages "
        "FROM candidates ORDER BY id DESC"
    )
    rows = c.fetchall()
    conn.close()
    return render_template("index.html", candidates=rows, json=json)


@app.post("/update/<int:cand_id>")
@login_required
def update_candidate(cand_id: int):
    payload = request.get_json(force=True, silent=True) or {}
    name = payload.get("name", "")
    first_name = payload.get("first_name", "")
    middle_name = payload.get("middle_name", "")
    last_name = payload.get("last_name", "")
    phone = payload.get("phone", "")
    email = payload.get("email", "")
    links = json.dumps(payload.get("links", []), ensure_ascii=False)
    education = json.dumps(payload.get("education", []), ensure_ascii=False)
    experience = json.dumps(payload.get("experience", []), ensure_ascii=False)
    skills = payload.get("skills", "")
    languages = payload.get("languages", "")

    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute(
        """UPDATE candidates SET
        name=?, first_name=?, middle_name=?, last_name=?, phone=?, email=?, links=?,
        education=?, experience=?, skills=?, languages=? WHERE id=?""",
        (
            name,
            first_name,
            middle_name,
            last_name,
            phone,
            email,
            links,
            education,
            experience,
            skills,
            languages,
            cand_id,
        ),
    )
    conn.commit()
    conn.close()
    return jsonify({"ok": True})


if __name__ == "__main__":
    init_db()
    app.run(debug=False)


================================================================================
// Path: dump.txt
================================================================================

================================================================================
PROJECT SUMMARY
================================================================================

Generated: 2025-10-21T02:39:01Z
Root: C:\Users\User\Documents\GitHub\ProjectUnknown
Python: 3.13.5

================================================================================
PROJECT TREE
================================================================================

ProjectUnknown/
├── ats_parser/
│   ├── __init__.py
│   ├── ingest.py
│   ├── llm.py
│   ├── models.py
│   ├── parser.py
│   ├── reconcile.py
│   ├── rules.py
│   └── sections.py
├── templates/
│   ├── _flash.html
│   ├── _theme.html
│   ├── admin_candidates.html
│   ├── admin_home.html
│   ├── auth_login.html
│   ├── auth_reset_request.html
│   ├── auth_reset_set.html
│   ├── auth_signup.html
│   └── index.html
├── uploads/
│   ├── 83027bdf40824802abb5d3b488c3662e_OlivierLachanceCV_English.pdf
│   └── a70599ab4bcd458bb485b39e650fd134_QuyVuLuong_CV.pdf
├── .gitattributes
├── .gitignore
├── backend.py
├── database.db
├── dump.txt
├── dump_project.py
├── README.md
├── requirements.txt
└── resume_parser.py

Directories: 3  Files: 28

================================================================================
FILE CONTENTS
================================================================================

================================================================================
// Path: README.md
================================================================================

# Mini ATS — Structured Resume Scanner (Phase)

A minimal ATS-style web app:
- Upload a **PDF resume**.
- Backend parses sections and extracts **structured fields** (Experience, Education, Projects).
- Data is stored in **SQLite** with JSON columns.
- Web UI shows **text boxes per field**; you can edit and **save** back to DB.

---

## Features

- Section-aware parsing (SUMMARY / EXPERIENCE / EDUCATION / PROJECTS / SKILLS / LANGUAGES).
- Heuristics for dates and roles; calculates **duration (months)** when possible.
- Stores arrays (lists of dicts) as **JSON** in SQLite.
- Inline **edit & save** for each candidate.
- Safe parser (guards against missing sections / malformed bullets).

---
```powershell
## Project Structure
ProjectUnknown/
├─ backend.py # Flask app + DB CRUD
├─ resume_parser.py # PDF → structured JSON (experience/education/projects)
├─ templates/
│ └─ index.html # Upload + editable cards UI
├─ uploads/ # Saved resumes (created on first upload)
├─ database.db # SQLite (auto-created)
├─ requirements.txt
└─ README.md
## Quickstart
```

> Tested on **Python 3.13**. Works on 3.10+.

### 1) Create venv & install deps
**Windows (PowerShell):**
```powershell
python -m venv .venv
.\.venv\Scripts\Activate.ps1
pip install -r requirements.txt

python backend.py
http://127.0.0.1:5000
# stop the app, then:
del database.db         # PowerShell
# or
rm database.db          # bash/zsh
# start the app again so it recreates the table


================================================================================
// Path: backend.py
================================================================================

# backend.py — Flask upload -> parse -> save -> render
from flask import (
    Flask,
    request,
    render_template,
    jsonify,
    redirect,
    url_for,
    session,
    flash,
)
import sqlite3, os, json, uuid
from resume_parser import parse_resume
from werkzeug.utils import secure_filename
from datetime import timedelta, datetime
from werkzeug.security import generate_password_hash, check_password_hash
import secrets

# Optional pure-Python MIME sniff (no system deps). If missing, we just skip.
try:
    import filetype  # pip install filetype
except Exception:
    filetype = None

app = Flask(__name__)
app.secret_key = os.environ.get("SECRET_KEY", "dev-secret-change-me")
app.permanent_session_lifetime = timedelta(minutes=30)
IDLE_TIMEOUT_MIN = 15
DB_PATH = "database.db"
ALLOWED_EXTS = {"pdf"}
app.config["MAX_CONTENT_LENGTH"] = 10 * 1024 * 1024  # 10 MB


def allowed_file(filename: str) -> bool:
    return "." in filename and filename.rsplit(".", 1)[1].lower() in ALLOWED_EXTS


def current_user():
    uid = session.get("user_id")
    if not uid:
        return None
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT id, username, is_admin FROM users WHERE id=?", (uid,))
    row = c.fetchone()
    conn.close()
    if not row:
        return None
    return {"id": row[0], "username": row[1], "is_admin": bool(row[2])}


def login_required(fn):
    from functools import wraps

    @wraps(fn)
    def wrapper(*args, **kwargs):
        if not session.get("user_id"):
            flash("Please log in to continue.", "warn")
            return redirect(url_for("login", next=request.path))
        return fn(*args, **kwargs)

    return wrapper


def admin_required(fn):
    from functools import wraps

    @wraps(fn)
    def wrapper(*args, **kwargs):
        user = current_user()
        if not user or not user["is_admin"]:
            flash("Admin access required.", "error")
            return redirect(url_for("login"))
        return fn(*args, **kwargs)

    return wrapper


@app.before_request
def enforce_idle_timeout():
    from datetime import datetime, timezone
    now = datetime.now(timezone.utc).timestamp()
    last = session.get("last_seen")
    if session.get("user_id"):
        if last and (now - last) > (IDLE_TIMEOUT_MIN * 60):
            # idle → logout
            session.clear()
            flash("You were logged out due to inactivity.", "info")
            return redirect(url_for("login"))
        session["last_seen"] = now


@app.route("/signup", methods=["GET", "POST"])
def signup():
    if request.method == "POST":
        username = (request.form.get("username") or "").strip()
        password = request.form.get("password") or ""
        if not username or not password:
            flash("Username and password are required.", "error")
            return redirect(url_for("signup"))
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        try:
            c.execute(
                "INSERT INTO users (username, password_hash, created_at) VALUES (?,?,?)",
                (
                    username,
                    generate_password_hash(password),
                    datetime.utcnow().isoformat(),
                ),
            )
            conn.commit()
        except sqlite3.IntegrityError:
            conn.close()
            flash("Username already exists.", "error")
            return redirect(url_for("signup"))
        # Auto-login after signup
        c.execute("SELECT id FROM users WHERE username=?", (username,))
        uid = c.fetchone()[0]
        conn.close()
        session.clear()
        session.permanent = True
        session["user_id"] = uid
        from datetime import datetime, timezone
        session["last_seen"] = datetime.now(timezone.utc).timestamp()
        flash("Account created. Welcome!", "success")
        return redirect(url_for("index"))
    return render_template("auth_signup.html")


@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        username = (request.form.get("username") or "").strip()
        password = request.form.get("password") or ""
        next_url = request.args.get("next") or url_for("index")

        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute(
            "SELECT id, password_hash, is_admin FROM users WHERE username=?",
            (username,),
        )
        row = c.fetchone()
        conn.close()

        if not row or not check_password_hash(row[1], password):
            flash("Invalid username or password.", "error")
            return redirect(url_for("login", next=next_url))

        session.clear()
        session.permanent = True
        session["user_id"] = row[0]
        session["last_seen"] = datetime.utcnow().timestamp()
        flash("Logged in successfully.", "success")
        return redirect(next_url)
    return render_template("auth_login.html", next=request.args.get("next"))


@app.route("/logout")
def logout():
    session.clear()
    flash("Logged out.", "info")
    return redirect(url_for("login"))


@app.route("/reset/request", methods=["GET", "POST"])
def reset_request():
    if request.method == "POST":
        username = (request.form.get("username") or "").strip()
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute("SELECT id FROM users WHERE username=?", (username,))
        row = c.fetchone()
        if not row:
            conn.close()
            flash("If that account exists, a reset token was created.", "info")
            return redirect(url_for("reset_request"))

        uid = row[0]
        token = secrets.token_urlsafe(24)
        expires = (datetime.utcnow() + timedelta(minutes=30)).isoformat()
        c.execute(
            "INSERT INTO reset_tokens (user_id, token, expires_at) VALUES (?,?,?)",
            (uid, token, expires),
        )
        conn.commit()
        conn.close()
        # For demo: show token and direct link
        flash(f"Reset token: {token}", "info")
        flash("Use the link below within 30 minutes.", "info")
        return redirect(url_for("reset_form", token=token))
    return render_template("auth_reset_request.html")


@app.route("/reset/<token>", methods=["GET", "POST"])
def reset_form(token):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute(
        "SELECT user_id, expires_at, used FROM reset_tokens WHERE token=?", (token,)
    )
    row = c.fetchone()
    if not row:
        conn.close()
        flash("Invalid or expired token.", "error")
        return redirect(url_for("reset_request"))
    user_id, expires_at, used = row
    if used:
        conn.close()
        flash("This token was already used.", "error")
        return redirect(url_for("reset_request"))
    if datetime.utcnow() > datetime.fromisoformat(expires_at):
        conn.close()
        flash("Token expired.", "error")
        return redirect(url_for("reset_request"))

    if request.method == "POST":
        pw = request.form.get("password") or ""
        if len(pw) < 6:
            flash("Password must be at least 6 characters.", "error")
            return redirect(url_for("reset_form", token=token))
        c.execute(
            "UPDATE users SET password_hash=? WHERE id=?",
            (generate_password_hash(pw), user_id),
        )
        c.execute("UPDATE reset_tokens SET used=1 WHERE token=?", (token,))
        conn.commit()
        conn.close()
        flash("Password updated. Please log in.", "success")
        return redirect(url_for("login"))
    conn.close()
    return render_template("auth_reset_set.html", token=token)


@app.route("/admin")
@admin_required
def admin_home():
    return redirect(url_for("admin_candidates"))


@app.route("/admin/candidates")
@admin_required
def admin_candidates():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT id, name, email, phone FROM candidates ORDER BY id DESC")
    rows = c.fetchall()
    conn.close()
    return render_template("admin_candidates.html", rows=rows)


@app.post("/admin/delete/candidate/<int:cand_id>")
@admin_required
def admin_delete_candidate(cand_id: int):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("DELETE FROM candidates WHERE id=?", (cand_id,))
    conn.commit()
    conn.close()
    flash(f"Candidate #{cand_id} deleted.", "success")
    return redirect(url_for("admin_candidates"))


def init_db():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute(
        """CREATE TABLE IF NOT EXISTS candidates (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT,                     -- full display name
            first_name TEXT,
            middle_name TEXT,
            last_name TEXT,
            phone TEXT,
            email TEXT,
            links TEXT,                    -- JSON array of strings
            education TEXT,                -- JSON
            experience TEXT,               -- JSON
            projects TEXT,                 -- JSON
            skills TEXT,                   -- CSV
            languages TEXT,                -- CSV
            raw_text TEXT
        )"""
    )
    # users table
    c.execute(
        """CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT UNIQUE NOT NULL,
            password_hash TEXT NOT NULL,
            is_admin INTEGER NOT NULL DEFAULT 0,
            created_at TEXT NOT NULL
        )"""
    )
    # password reset tokens
    c.execute(
        """CREATE TABLE IF NOT EXISTS reset_tokens (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            token TEXT UNIQUE NOT NULL,
            expires_at TEXT NOT NULL,
            used INTEGER NOT NULL DEFAULT 0,
            FOREIGN KEY(user_id) REFERENCES users(id)
        )"""
    )
    conn.commit()
    # Seed a default admin once (username: admin, password: 123)
    c.execute("SELECT 1 FROM users WHERE username='admin'")
    if not c.fetchone():
        from datetime import datetime
        from werkzeug.security import generate_password_hash

        c.execute(
            "INSERT INTO users (username, password_hash, is_admin, created_at) VALUES (?,?,?,?)",
            (
                "admin",
                generate_password_hash("123"),
                1,
                datetime.utcnow().isoformat(),
            ),
        )
        conn.commit()
    conn.close()


@app.route("/", methods=["GET", "POST"])
@login_required
def index():
    if request.method == "POST":
        f = request.files.get("resume")
        if not (f and allowed_file(f.filename)):
            return render_template("index.html", candidates=[], json=json)

        os.makedirs("uploads", exist_ok=True)
        safe = secure_filename(f.filename) or "resume.pdf"
        uid = uuid.uuid4().hex
        path = os.path.join("uploads", f"{uid}_{safe}")
        f.save(path)

        # Optional lightweight MIME check (pip-only; no libmagic)
        if filetype:
            kind = filetype.guess(path)
            if not (kind and kind.mime == "application/pdf"):
                try:
                    os.remove(path)
                except Exception:
                    pass
                return render_template("index.html", candidates=[], json=json)

        parsed = parse_resume(path)

        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute(
            """INSERT INTO candidates
            (name, first_name, middle_name, last_name, phone, email, links,
                education, experience, skills, languages, raw_text)
            VALUES (?,?,?,?,?,?,?,?,?,?,?,?)""",
            (
                parsed.get("name",""),
                parsed.get("first_name", ""),
                parsed.get("middle_name", ""),
                parsed.get("last_name", ""),
                parsed.get("phone", ""),
                parsed.get("email", ""),
                json.dumps(parsed.get("links", []), ensure_ascii=False),
                json.dumps(parsed.get("education", []), ensure_ascii=False),
                json.dumps(parsed.get("experience", []), ensure_ascii=False),
                parsed.get("skills", ""),
                parsed.get("languages", ""),
                parsed.get("raw_text", ""),
            ),
        )

        conn.commit()
        conn.close()

    # fetch list
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute(
        "SELECT id, name, first_name, middle_name, last_name, phone, email, links, "
        "education, experience, skills, languages "
        "FROM candidates ORDER BY id DESC"
    )
    rows = c.fetchall()
    conn.close()
    return render_template("index.html", candidates=rows, json=json)


@app.post("/update/<int:cand_id>")
@login_required
def update_candidate(cand_id: int):
    payload = request.get_json(force=True, silent=True) or {}
    name = payload.get("name", "")
    first_name = payload.get("first_name", "")
    middle_name = payload.get("middle_name", "")
    last_name = payload.get("last_name", "")
    phone = payload.get("phone", "")
    email = payload.get("email", "")
    links = json.dumps(payload.get("links", []), ensure_ascii=False)
    education = json.dumps(payload.get("education", []), ensure_ascii=False)
    experience = json.dumps(payload.get("experience", []), ensure_ascii=False)
    skills = payload.get("skills", "")
    languages = payload.get("languages", "")

    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute(
        """UPDATE candidates SET
        name=?, first_name=?, middle_name=?, last_name=?, phone=?, email=?, links=?,
        education=?, experience=?, skills=?, languages=? WHERE id=?""",
        (
            name,
            first_name,
            middle_name,
            last_name,
            phone,
            email,
            links,
            education,
            experience,
            skills,
            languages,
            cand_id,
        ),
    )
    conn.commit()
    conn.close()
    return jsonify({"ok": True})


if __name__ == "__main__":
    init_db()
    app.run(debug=False)


================================================================================
// Path: dump_project.py
================================================================================

import os
import sys
import argparse
from datetime import datetime
from typing import Iterable, List, Set, Tuple

# ---------- Defaults tuned for StockAI ----------
DEFAULT_ROOT = "."
DEFAULT_OUTPUT = "dump.txt"
DEFAULT_MAX_FILE_SIZE = 1 * 1024 * 1024  # 1 MB

# Folders we usually exclude from **tree** to avoid noise; use --tree-all to include anyway
TREE_EXCLUDE_ANYWHERE: Set[str] = {".git", ".venv", "__pycache__", ".idea", ".vscode"}

# Folders we exclude from **content**, but still show in the tree
CONTENT_EXCLUDE_ANYWHERE: Set[str] = {
    ".git", ".venv", "__pycache__", ".idea", ".vscode", "node_modules",
    "dist", "build", ".mastra",
    # project artifacts
    "backtests", "notebooks",
}

# Filenames to ignore for content
IGNORE_FILES_ANYWHERE: Set[str] = {
    ".env", ".env.local", ".python-version", "Pipfile.lock",
    "package-lock.json", "tsconfig.json", "cookies.txt",
}

# Always include these names (even without extensions) in content
INCLUDE_FILENAMES: Set[str] = {"Makefile", "Dockerfile"}

# Binary-ish extensions (content skipped; still listed in tree)
BINARY_EXTS: Set[str] = {
    # archives / binaries
    ".zip", ".gz", ".tar", ".rar", ".7z", ".exe", ".dll", ".so", ".a",
    # db / parquet / arrow
    ".sqlite", ".sqlite3", ".db", ".db-journal", ".parquet", ".arrow",
    # images
    ".png", ".jpg", ".jpeg", ".gif", ".bmp", ".tiff", ".ico", ".webp",
    # docs
    ".pdf", ".doc", ".docx", ".ppt", ".pptx", ".xls", ".xlsx",
    # audio/video
    ".mp3", ".wav", ".m4a", ".mp4", ".mov", ".avi", ".mkv",
}

# Text/code extensions included by default for content
DEFAULT_INCLUDE_EXTS: Set[str] = {
    ".py", ".toml", ".yaml", ".yml", ".json", ".md", ".txt", ".cfg", ".ini",
    ".sql", ".sh", ".bat", ".ps1", ".html", ".css", ".js", ".ts", ".tsx", ".jsx",
}
# ------------------------------------------------

def parse_args():
    p = argparse.ArgumentParser(description="Dump project TREE + text/code contents into a single file.")
    p.add_argument("--root", default=DEFAULT_ROOT, help="Root directory to scan")
    p.add_argument("--output", default=DEFAULT_OUTPUT, help="Output file path")
    p.add_argument("--max-size", type=int, default=DEFAULT_MAX_FILE_SIZE, help="Max file size (bytes) for content")
    p.add_argument("--include-ext", default=",".join(sorted(DEFAULT_INCLUDE_EXTS)),
                   help="Comma-separated list of file extensions to include as content (e.g. .py,.toml,.yaml)")
    p.add_argument("--tree-all", action="store_true", help="Include ALL directories in the tree (even .git/.venv)")
    p.add_argument("--no-content", action="store_true", help="Only print the tree (no file contents)")
    p.add_argument("--placeholders", action="store_true",
                   help="Write placeholder blocks for skipped files (binary/large/not-included)")
    return p.parse_args()

def _normalize_exts(s: str) -> Set[str]:
    exts = set()
    for raw in s.split(","):
        e = raw.strip()
        if not e:
            continue
        if not e.startswith("."):
            e = "." + e
        exts.add(e.lower())
    return exts

def is_probably_binary(filepath: str, chunk_size: int = 1024) -> bool:
    try:
        with open(filepath, "rb") as f:
            chunk = f.read(chunk_size)
            if not chunk:
                return False
            if b"\0" in chunk:
                return True
            text_chars = bytearray({7,8,9,10,12,13,27} | set(range(0x20, 0x100)) - {0x7F})
            non_text = sum(1 for b in chunk if b not in text_chars)
            return (non_text / max(1, len(chunk))) > 0.30
    except Exception:
        return True

def should_hide_in_tree(name: str, include_all: bool) -> bool:
    return (name in TREE_EXCLUDE_ANYWHERE) and (not include_all)

def should_skip_content_dir(name: str) -> bool:
    return name in CONTENT_EXCLUDE_ANYWHERE

def should_include_content(fname: str, include_exts: Set[str]) -> bool:
    if fname in INCLUDE_FILENAMES:
        return True
    base, ext = os.path.splitext(fname)
    ext = ext.lower()
    if ext in BINARY_EXTS:
        return False
    if include_exts and ext not in include_exts:
        return False
    return True

def tree_lines(root: str, include_all: bool) -> Tuple[List[str], int, int]:
    """
    Return (lines, dir_count, file_count) for a pretty tree.
    """
    lines: List[str] = []
    dir_count = 0
    file_count = 0

    def walk(dir_path: str, prefix: str = ""):
        nonlocal dir_count, file_count
        try:
            entries = sorted(os.scandir(dir_path), key=lambda e: (not e.is_dir(), e.name.lower()))
        except PermissionError:
            return
        # filter only for tree display
        entries = [e for e in entries if not (e.is_dir() and should_hide_in_tree(e.name, include_all))]
        total = len(entries)
        for idx, e in enumerate(entries):
            connector = "└── " if idx == total - 1 else "├── "
            if e.is_dir():
                lines.append(f"{prefix}{connector}{e.name}/")
                dir_count += 1
                next_prefix = f"{prefix}{'    ' if idx == total - 1 else '│   '}"
                walk(e.path, next_prefix)
            else:
                file_count += 1
                lines.append(f"{prefix}{connector}{e.name}")

    root_label = os.path.basename(os.path.abspath(root)) or root
    lines.append(f"{root_label}/")
    walk(root)
    return lines, dir_count, file_count

def write_header(dump, title: str):
    sep = "=" * max(80, len(title) + 10)
    dump.write(f"{sep}\n")
    dump.write(f"{title}\n")
    dump.write(f"{sep}\n\n")

def write_file_header(dump, rel_path: str):
    header = f"// Path: {rel_path}"
    sep_len = max(80, len(header))
    dump.write("=" * sep_len + "\n")
    dump.write(header + "\n")
    dump.write("=" * sep_len + "\n\n")

def iter_all_files(root: str) -> Iterable[str]:
    for cur_root, dirs, files in os.walk(root, topdown=True):
        dirs[:] = sorted(dirs)
        for fname in sorted(files):
            yield os.path.join(cur_root, fname)

def main():
    args = parse_args()
    root = args.root
    out_path = args.output
    include_exts = _normalize_exts(args.include_ext)

    if not os.path.isdir(root):
        print(f"ERROR: root directory not found: {root}")
        sys.exit(1)

    with open(out_path, "w", encoding="utf-8", errors="ignore") as dump:
        # 1) Project metadata
        write_header(dump, "PROJECT SUMMARY")
        dump.write(f"Generated: {datetime.utcnow().isoformat(timespec='seconds')}Z\n")
        dump.write(f"Root: {os.path.abspath(root)}\n")
        dump.write(f"Python: {sys.version.split()[0]}\n\n")

        # 2) Tree
        write_header(dump, "PROJECT TREE")
        lines, dcnt, fcnt = tree_lines(root, include_all=args.tree_all)
        dump.write("\n".join(lines) + "\n\n")
        dump.write(f"Directories: {dcnt}  Files: {fcnt}\n\n")

        if args.no_content:
            print(f"Done (tree only). Wrote {out_path}")
            return

        # 3) File contents (text/code only)
        write_header(dump, "FILE CONTENTS")
        processed = 0
        skipped = 0

        for fpath in iter_all_files(root):
            rel = os.path.relpath(fpath, root).replace("\\", "/")
            fname = os.path.basename(fpath)
            parent = os.path.basename(os.path.dirname(fpath))

            # Skip content if under excluded dirs
            if parent in CONTENT_EXCLUDE_ANYWHERE or any(p in CONTENT_EXCLUDE_ANYWHERE for p in rel.split("/") if p):
                # still optionally write placeholder
                if args.placeholders:
                    write_file_header(dump, rel)
                    dump.write(f"// [skipped: directory excluded from content]\n\n")
                skipped += 1
                continue

            # Skip content by rule
            if not should_include_content(fname, include_exts):
                if args.placeholders:
                    write_file_header(dump, rel)
                    dump.write(f"// [skipped: extension not in include list]\n\n")
                skipped += 1
                continue

            # Size & binary checks
            try:
                size = os.path.getsize(fpath)
            except OSError as e:
                if args.placeholders:
                    write_file_header(dump, rel)
                    dump.write(f"// [skipped: stat error: {e}]\n\n")
                skipped += 1
                continue

            if size > args.max_size:
                if args.placeholders:
                    write_file_header(dump, rel)
                    dump.write(f"// [skipped: large file ~{size} bytes]\n\n")
                skipped += 1
                continue

            if is_probably_binary(fpath):
                if args.placeholders:
                    write_file_header(dump, rel)
                    dump.write(f"// [skipped: binary-like file]\n\n")
                skipped += 1
                continue

            # Emit content
            try:
                with open(fpath, "r", encoding="utf-8", errors="ignore") as src:
                    content = src.read()
                write_file_header(dump, rel)
                dump.write(content)
                dump.write("\n\n")
                processed += 1
                if processed % 50 == 0:
                    print(f"... wrote {processed} files")
            except Exception as e:
                if args.placeholders:
                    write_file_header(dump, rel)
                    dump.write(f"// [skipped: read error: {e}]\n\n")
                skipped += 1
                continue

        dump.write(f"\n// Summary: wrote {processed} files, skipped {skipped} files.\n")

    print(f"Done. TREE + contents written to {out_path}")

if __name__ == "__main__":
    main()


================================================================================
// Path: requirements.txt
================================================================================

# --- Web (Flask app you have now) ---
Flask>=3.0.3
Werkzeug>=3.0.3
Jinja2>=3.1.4
itsdangerous>=2.2.0
click>=8.1.7

# --- PDF parsing (pip-only) ---
PyMuPDF>=1.24
pdfplumber>=0.11
pdfminer.six>=20231228

# --- OCR fallback (no system deps) ---
easyocr>=1.7.2
torch>=2.3          # CPU wheel

# --- NLP / parsing helpers ---
regex>=2024.9.11
python-dateutil>=2.9.0.post0
phonenumbers>=8.13.44
email-validator>=2.2.0

# --- Optional, pure-Python file type sniffing used in backend.py (safe to keep) ---
filetype>=1.2.0

# --- Nice-to-have logs ---
rich>=13.8

# --- NLP ---
spacy>=3.7
srsly>=2.4
typer>=0.12

# optional but useful:
spacy-lookups-data>=1.0

# --- New/updated deps for ats_parser (hybrid parser) ---
pydantic>=2.7
rapidfuzz>=3.9
langdetect>=1.0.9
httpx>=0.27
requests>=2.32
openai>=1.40        # only needed if USE_LLM=1

dateparser>=1.2

================================================================================
// Path: resume_parser.py
================================================================================


from __future__ import annotations
# Drop-in replacement using ats_parser
from ats_parser import parse_file, adapt_for_backend

def parse_resume(filepath: str) -> dict:
    res = parse_file(filepath)
    return adapt_for_backend(res)


================================================================================
// Path: ats_parser/__init__.py
================================================================================


"""Hybrid resume parser package (rules + optional LLM)."""
from .parser import parse_file, parse_bytes, adapt_for_backend


================================================================================
// Path: ats_parser/ingest.py
================================================================================


from __future__ import annotations
import os, re, unicodedata
from typing import Tuple
import fitz  # PyMuPDF
import pdfplumber

USE_OCR = os.getenv("USE_OCR", "0") == "1"
OCR_LANGS = (os.getenv("OCR_LANGS", "en").split(","))

def _norm_ws(s: str) -> str:
    if not s:
        return ""
    s = s.replace("\ufeff", "")
    s = "".join(" " if (ch.isspace() or unicodedata.category(ch) == "Zs") else ch for ch in s)
    return re.sub(r"\s+", " ", s).strip()

def _page_blocks_sorted(page):
    blocks = page.get_text("blocks") or []
    blocks.sort(key=lambda b: (round(b[1],1), round(b[0],1)))
    return blocks

def _blocks_to_text(blocks):
    lines = []
    for b in blocks:
        t = (b[4] or "").strip()
        if t:
            lines.append(t)
    return "\n".join(lines)

_ocr_reader = None
def _get_ocr():
    global _ocr_reader
    if _ocr_reader is None:
        import easyocr  # lazy
        _ocr_reader = easyocr.Reader(OCR_LANGS, gpu=False)
    return _ocr_reader

def read_pdf_text(path: str) -> Tuple[str, int]:
    """Return (text, ocr_pages_used). Uses blocks; falls back to text/ocr/pdfplumber."""
    doc = fitz.open(path)
    assembled, ocr_count = [], 0
    for i, page in enumerate(doc):
        raw = _blocks_to_text(_page_blocks_sorted(page)) or (page.get_text("text") or "")
        if len(_norm_ws(raw)) < 120 and USE_OCR:
            # high-res pix + OCR
            mat = fitz.Matrix(300/72, 300/72).preRotate((page.rotation or 0)%360)
            pix = page.get_pixmap(matrix=mat, alpha=False)
            img = pix.tobytes("png")
            reader = _get_ocr()
            lines = reader.readtext(img, detail=0, paragraph=True)
            raw = "\n".join(l.strip() for l in lines if l and l.strip())
            ocr_count += 1
        assembled.append(raw)
    doc.close()
    text = "\n".join(assembled).strip()

    # rescue with pdfplumber if still sparse
    if len(_norm_ws(text)) < 120:
        try:
            with pdfplumber.open(path) as pdf:
                text2 = "\n".join((p.extract_text() or "") for p in pdf.pages)
            if len(_norm_ws(text2)) > len(_norm_ws(text)):
                text = text2
        except Exception:
            pass

    return (text or "") + "\n", ocr_count


================================================================================
// Path: ats_parser/llm.py
================================================================================

from typing import List
import os, json, requests
from .models import ExperienceItem, DateSpan

USE_LLM = os.getenv("USE_LLM", "0") == "1"


def extract_experience_llm(text: str) -> List[ExperienceItem]:
    """
    LLM extractor for EXPERIENCE.
    - Requires USE_LLM=1 and OPENAI_API_KEY.
    - Enforces a JSON *array* via json_schema.
    """
    if not USE_LLM or not (text or "").strip():
        return []
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        return []

    model = os.getenv("OPENAI_MODEL", "gpt-4o-mini")
    schema = {
        "name": "experience_array",
        "schema": {
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "title": {"type": "string"},
                    "company": {"type": "string"},
                    "location": {"type": "string"},
                    "dates": {
                        "type": "object",
                        "properties": {
                            "start": {"type": ["string", "null"]},
                            "end": {"type": ["string", "null"]},
                            "months": {"type": ["integer", "null"]},
                        },
                    },
                    "bullets": {"type": "array", "items": {"type": "string"}},
                    "technologies": {"type": "array", "items": {"type": "string"}},
                    "confidence": {"type": "number"},
                },
                "required": ["title", "company", "dates", "bullets"],
            },
        },
        "strict": True,
    }

    prompt = f"""Extract the candidate's work EXPERIENCE from the text.
Return a JSON array. Dates must be YYYY-MM or null. If end date is current, set end to "Present".
Text:
{text}
"""

    try:
        r = requests.post(
            "https://api.openai.com/v1/responses",
            headers={
                "Authorization": f"Bearer {api_key}",
                "Content-Type": "application/json",
            },
            json={
                "model": model,
                "input": prompt,
                "response_format": {"type": "json_schema", "json_schema": schema},
                "max_output_tokens": 2000,
            },
            timeout=45,
        )
        data = r.json()
        # Responses API (preferred)
        out_text = ""
        try:
            out_text = data["output"][0]["content"][0]["text"]
        except Exception:
            # Chat-style fallback
            out_text = (
                data.get("choices", [{}])[0].get("message", {}).get("content", "")
            )

        arr = json.loads(out_text) if out_text else []
        if not isinstance(arr, list):
            return []
        out: List[ExperienceItem] = []
        for it in arr:
            out.append(
                ExperienceItem(
                    title=it.get("title", ""),
                    company=it.get("company", ""),
                    location=it.get("location", ""),
                    dates=DateSpan(**(it.get("dates") or {})),
                    bullets=it.get("bullets") or [],
                    technologies=it.get("technologies") or [],
                    confidence=float(it.get("confidence") or 0.8),
                )
            )
        return out
    except Exception:
        return []


================================================================================
// Path: ats_parser/models.py
================================================================================


from __future__ import annotations
from pydantic import BaseModel, Field, EmailStr, HttpUrl, ConfigDict
from typing import List, Optional

class DateSpan(BaseModel):
    start: Optional[str] = Field(default=None, description="YYYY-MM or None")
    end: Optional[str] = Field(default=None, description="YYYY-MM or 'Present' or None")
    months: Optional[int] = None

class ExperienceItem(BaseModel):
    title: Optional[str] = ""
    company: Optional[str] = ""
    location: Optional[str] = ""
    dates: DateSpan = DateSpan()
    bullets: List[str] = []
    technologies: List[str] = []
    confidence: float = 0.0

class EducationItem(BaseModel):
    degree: Optional[str] = ""
    field: Optional[str] = ""
    school: Optional[str] = ""
    location: Optional[str] = ""
    dates: DateSpan = DateSpan()
    gpa: Optional[str] = None

class Contact(BaseModel):
    name: Optional[str] = ""
    email: Optional[EmailStr] = None
    phone: Optional[str] = None
    location: Optional[str] = None
    linkedin: Optional[HttpUrl] = None
    github: Optional[HttpUrl] = None
    websites: List[HttpUrl] = []

class Resume(BaseModel):
    model_config = ConfigDict(arbitrary_types_allowed=True)
    contact: Contact = Contact()
    summary: Optional[str] = ""
    skills: List[str] = []
    experience: List[ExperienceItem] = []
    education: List[EducationItem] = []
    certifications: List[str] = []
    languages: List[str] = []
    raw_text: str = ""
    flags: dict = {}


================================================================================
// Path: ats_parser/parser.py
================================================================================

from __future__ import annotations
from typing import List
from .models import Resume, Contact, ExperienceItem, EducationItem, DateSpan
from .ingest import read_pdf_text
from .sections import split_sections
from . import rules
from .llm import extract_experience_llm
from .reconcile import merge_experience


def _split_name(full: str):
    s = (full or "").strip()
    if not s:
        return "", "", ""
    parts = s.split()
    if len(parts) == 1:
        return parts[0], "", ""
    if len(parts) == 2:
        return parts[0], "", parts[1]
    return parts[0], " ".join(parts[1:-1]), parts[-1]


def parse_file(path: str) -> Resume:
    text, ocr_pages = read_pdf_text(path)
    secs = split_sections(text)

    contacts = rules.extract_contacts(text)
    skills_txt = rules.skills_text(secs.get("SKILLS", []))

    exp_rule = [
        ExperienceItem(
            title=it["title"],
            company=it["company"],
            location=it["location"],
            dates=DateSpan(**it["dates"]),
            bullets=it["bullets"],
            technologies=it["technologies"],
            confidence=it.get("confidence", 0.55),
        )
        for it in rules.fallback_experience(secs.get("EXPERIENCE") or text)
    ]
    if not exp_rule:
        exp_rule = [ExperienceItem(
            title=it["title"], company=it["company"], location=it["location"],
            dates=DateSpan(**it["dates"]), bullets=it["bullets"], technologies=it["technologies"],
            confidence=it.get("confidence",0.55)
        ) for it in rules.fallback_experience(text)]
    edu_items: List[EducationItem] = []

    exp_llm: List[ExperienceItem] = (
        extract_experience_llm("\n".join(secs.get("EXPERIENCE", []))) or []
    )

    experience = merge_experience(exp_rule, exp_llm)

    resume = Resume(
        contact=Contact(
            name=contacts.get("name", ""),
            email=contacts.get("email") or None,
            phone=contacts.get("phone") or None,
            websites=contacts.get("links") or [],
        ),
        summary=" ".join(secs.get("SUMMARY", [])[:5]),
        skills=[
            s.strip()
            for s in (skills_txt.split(",") if skills_txt else [])
            if s.strip()
        ],
        experience=experience,
        education=edu_items,
        certifications=[],
        languages=[],
        raw_text=text,
        flags={
            "used_ocr": bool(ocr_pages),
            "sections_found": {k: len(v or []) for k, v in secs.items()},
        },
    )
    return resume


def parse_bytes(data: bytes) -> Resume:
    import tempfile, os

    with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as tmp:
        tmp.write(data)
        tmp.flush()
        path = tmp.name
    try:
        return parse_file(path)
    finally:
        try:
            os.remove(path)
        except Exception:
            pass


def adapt_for_backend(resume: Resume) -> dict:
    name = resume.contact.name or ""

    def _split_name(full: str):
        s = (full or "").strip()
        if not s:
            return "", "", ""
        parts = s.split()
        if len(parts) == 1:
            return parts[0], "", ""
        if len(parts) == 2:
            return parts[0], "", parts[1]
        return parts[0], " ".join(parts[1:-1]), parts[-1]

    first, middle, last = _split_name(name)

    # Flatten experience for your UI
    exp_flat = []
    for e in resume.experience:
        exp_flat.append(
            {
                "position": e.title or "",
                "company_name": e.company or "",
                "location": e.location or "",
                "start_date": (e.dates.start or ""),
                "end_date": (e.dates.end or ""),
                "duration_months": e.dates.months,
                "description": "\n".join(e.bullets).strip(),
            }
        )

    # Flatten education similarly (if you add education later)
    edu_flat = []
    for ed in resume.education:
        # try to pull years from ed.dates.start/end if they exist like 'YYYY-MM'
        sy = (ed.dates.start or "")[:4] if (ed.dates and ed.dates.start) else ""
        ey = (ed.dates.end or "")[:4] if (ed.dates and ed.dates.end) else ""
        edu_flat.append(
            {
                "level": ed.degree or "",
                "field": ed.field or "",
                "school_name": ed.school or "",
                "location": ed.location or "",
                "start_year": sy,
                "end_year": ey,
            }
        )

    return {
        "name": name,
        "first_name": first,
        "middle_name": middle,
        "last_name": last,
        "phone": resume.contact.phone or "",
        "email": str(resume.contact.email) if resume.contact.email else "",
        "links": [str(u) for u in (resume.contact.websites or [])],
        "education": edu_flat,  # <- flattened for your template
        "experience": exp_flat,  # <- flattened for your template
        "skills": ", ".join(resume.skills),
        "languages": ", ".join(resume.languages),
        "raw_text": resume.raw_text,
    }


================================================================================
// Path: ats_parser/reconcile.py
================================================================================

from __future__ import annotations
from typing import List
from rapidfuzz import fuzz
from .models import ExperienceItem


def dedupe_keep_order(items: List[str]) -> List[str]:
    seen = set()
    out = []
    for s in items:
        key = s.strip().lower()
        if key and key not in seen:
            seen.add(key)
            out.append(s.strip())
    return out


def merge_experience(
    rule_items: List[ExperienceItem], llm_items: List[ExperienceItem]
) -> List[ExperienceItem]:
    if not llm_items:
        return rule_items
    if not rule_items:
        return llm_items
    out: List[ExperienceItem] = []
    used = [False] * len(llm_items)
    for r in rule_items:
        best_i, best = -1, 0
        for i, l in enumerate(llm_items):
            if used[i]:
                continue
            score = 0
            if r.company and l.company:
                score += fuzz.token_set_ratio(r.company, l.company)
            if r.title and l.title:
                score += fuzz.token_set_ratio(r.title, l.title)
            if score > best:
                best = score
                best_i = i
        if best >= 120:
            l = llm_items[best_i]
            used[best_i] = True
            merged = ExperienceItem(
                title=l.title or r.title,
                company=l.company or r.company,
                location=l.location or r.location,
                dates=l.dates if (l.dates.start or l.dates.end) else r.dates,
                bullets=l.bullets or r.bullets,
                technologies=list({*r.technologies, *l.technologies}),
                confidence=max(r.confidence, l.confidence),
            )
            out.append(merged)
        else:
            out.append(r)
    for i, l in enumerate(llm_items):
        if not used[i]:
            out.append(l)
    return out


================================================================================
// Path: ats_parser/rules.py
================================================================================

from __future__ import annotations
import re
from typing import List, Tuple
from datetime import datetime
import phonenumbers
try:
    import dateparser
except Exception:
    dateparser = None

EMAIL = re.compile(r"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}")
LINK = re.compile(r"\b(?:https?://|www\.)[^\s)]+", re.I)
MONTHS = (
    r"(?:Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|"
    r"Jul(?:y)?|Aug(?:ust)?|Sep(?:t|tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)"
)
YEAR = r"(?:19|20)\d{2}"
NUM_MMYYYY = r"(?:0?[1-9]|1[0-2])[-/\.](?:\d{4})"
PRESENT = r"(?:Present|Current|Now|Today)"
RANGE_SEP = r"(?:\s*(?:-|–|—|to)\s*)"
DATE_TOKEN = rf"(?:{MONTHS}\s+{YEAR}|{YEAR}|{NUM_MMYYYY})"
DATE_RE = re.compile(
    rf"(?P<start>{DATE_TOKEN}){RANGE_SEP}(?P<end>{DATE_TOKEN}|{PRESENT})", re.I
)

BULLET = re.compile(r"^(\s*[-•‣∙·*]\s+)")
TITLE_HINT = re.compile(
    r"\b(senior|sr\.?|jr\.?|junior|lead|principal|staff|head|director|manager|"
    r"engineer|developer|analyst|consultant|architect|intern)\b",
    re.I,
)
COMPANY_SUFFIX = re.compile(
    r"\b(inc\.?|corp\.?|llc|ltd\.?|co\.?|company|capital|fund|bank|group|partners?|"
    r"systems?|labs?|studio|technolog(?:y|ies)|solutions?)\b",
    re.I,
)


def norm(s: str) -> str:
    return re.sub(r"\s+", " ", (s or "").strip())


def parse_date_range(s: str):
    m = DATE_RE.search(s or "")

    def to_ym(tok: str):
        if not tok:
            return None
        if re.fullmatch(PRESENT, tok, re.I):
            return "Present"
        # Try simple numeric patterns first
        if re.fullmatch(YEAR, tok):
            return f"{tok}-01"
        mm = re.match(r"(0?[1-9]|1[0-2])[-/\.]([0-9]{4})", tok)
        if mm:
            return f"{mm.group(2)}-{int(mm.group(1)):02d}"
        # Month name forms (EN/FR) via dateparser
        dt = dateparser.parse(tok, languages=["en", "fr"]) if dateparser else None
        if dt:
            return f"{dt.year}-{dt.month:02d}"
        return None

    if m:
        s_norm, e_norm = to_ym(m.group("start")), to_ym(m.group("end"))
        # compute months
        months = None
        try:
            if s_norm and e_norm and e_norm != "Present":
                ys, ms = map(int, s_norm.split("-"))
                ye, me = map(int, e_norm.split("-"))
                months = (ye - ys) * 12 + (me - ms) + 1
        except Exception:
            months = None
        return s_norm, e_norm, months

    # Fallback: split on common separators and parse both sides
    for sep in [" - ", " – ", " — ", " to ", "–", "—", "-", "– ", " — "]:
        if sep in s:
            left, right = s.split(sep, 1)
            ls, rs = to_ym(left.strip()), to_ym(right.strip())
            if ls or rs:
                months = None
                try:
                    if ls and rs and rs != "Present":
                        ys, ms = map(int, ls.split("-"))
                        ye, me = map(int, rs.split("-"))
                        months = (ye - ys) * 12 + (me - ms) + 1
                except Exception:
                    months = None
                return ls, rs, months

    return None, None, None


def extract_contacts(text: str) -> dict:
    emails = EMAIL.findall(text) or []
    links = list(dict.fromkeys(LINK.findall(text)))[:5]
    phone = None
    for m in phonenumbers.PhoneNumberMatcher(text, "CA"):
        phone = phonenumbers.format_number(
            m.number, phonenumbers.PhoneNumberFormat.INTERNATIONAL
        )
        break
    # naive name guess: first line with 2-4 TitleCased tokens
    name = ""
    for ln in text.splitlines()[:12]:
        s = norm(ln)
        if not s or len(s) > 60:
            continue
        if any(ch.isdigit() for ch in s):
            continue
        toks = [t for t in s.split() if re.match(r"^[A-Z][a-zA-Z-]+$", t)]
        if 2 <= len(toks) <= 4:
            name = s
            break
    return {
        "email": emails[0] if emails else "",
        "phone": phone or "",
        "links": links,
        "name": name,
    }


def _looks_like_title(s: str) -> bool:
    s = norm(s)
    if not s or s.endswith("."):
        return False
    if TITLE_HINT.search(s):
        return True
    toks = [t for t in s.split() if t.isalpha()]
    if not toks:
        return False
    caps = sum(1 for t in toks if t[0].isupper() and not t.isupper())
    return caps / len(toks) >= 0.6 and len(toks) <= 7


VERB_HINT = re.compile(
    r"\b(built|designed|developed|managed|led|mentored|supported|created|owned|implemented|improved|analyzed|wrote|drove|delivered)\b",
    re.I,
)


def _looks_like_company(s: str) -> bool:
    s = norm(s)
    if not s or s.lower().startswith(("http://", "https://", "www.")):
        return False
    if VERB_HINT.search(s):
        return False
    if COMPANY_SUFFIX.search(s):
        return True
    toks = [t for t in s.split() if t.isalpha()]
    if 2 <= len(toks) <= 6:
        caps = sum(1 for t in toks if t[0].isupper() and not t.isupper())
        if caps >= 2 and len(s) <= 48:
            return True
    return False


def _guess_title_company_from_buffer(buf: list[str]) -> tuple[str, str]:
    window = [norm(x) for x in buf if norm(x)][-6:]
    title, company = "", ""
    for i in range(len(window) - 1, -1, -1):
        if _looks_like_company(window[i]):
            company = window[i]
            for j in range(i - 1, -1, -1):
                if _looks_like_title(window[j]):
                    title = window[j]
                    break
            break
    if not title:
        for i in range(len(window) - 1, -1, -1):
            if _looks_like_title(window[i]):
                title = window[i]
                break
    if not company:
        for i in range(len(window) - 1, -1, -1):
            if _looks_like_company(window[i]):
                company = window[i]
                break
    return title, company


def fallback_experience(text_or_lines) -> list[dict]:
    lines = [
        norm(l)
        for l in (
            text_or_lines
            if isinstance(text_or_lines, list)
            else (text_or_lines or "").splitlines()
        )
        if norm(l)
    ]
    items, i, n = [], 0, len(lines)

    def gather_desc(start_idx: int):
        buf, j = [], start_idx
        while j < n:
            s = lines[j]
            if DATE_RE.search(s):
                break
            if _looks_like_title(s) or _looks_like_company(s):
                break
            if len(s) > 110:
                break
            buf.append(BULLET.sub("", s))
            j += 1
        return ("\n".join(buf).strip(), j)

    while i < n:
        line = lines[i]
        if not DATE_RE.search(line):
            i += 1
            continue
        start, end, months = parse_date_range(line)
        ctx = lines[max(0, i - 5) : i]
        title, company = _guess_title_company_from_buffer(ctx)
        desc, stop = gather_desc(i + 1)
        if title or company or desc:
            items.append(
                {
                    "title": title,
                    "company": company,
                    "location": "",
                    "dates": {"start": start, "end": end, "months": months},
                    "bullets": [b for b in (desc.split("\n") if desc else []) if b],
                    "technologies": [],
                    "confidence": 0.55,
                }
            )
        i = max(i + 1, stop)
    # dedupe
    seen, uniq = set(), []
    for it in items:
        key = (
            it["company"].lower(),
            it["title"].lower(),
            it["dates"]["start"],
            it["dates"]["end"],
        )
        if key not in seen:
            seen.add(key)
            uniq.append(it)
    return uniq


def skills_text(lines: list[str]) -> str:
    # stop if we hit sentences/dates/other sections; then split on separators
    out = []
    for l in lines or []:
        s = norm(re.sub(r"^[\-•*]\s*", "", l))
        if not s:
            continue
        if DATE_RE.search(s):
            break
        if re.search(r"\b(education|experience|projects?|languages?)\b", s, re.I):
            break
        if len(s) > 80 and re.search(
            r"\b(built|designed|developed|managed|worked|implemented|created)\b",
            s,
            re.I,
        ):
            break
        out.append(s)
    tokens = []
    for chunk in re.split(r"[,;/|]", " ".join(out)):
        token = norm(chunk)
        if len(token) >= 2:
            tokens.append(token)
    tokens = list(dict.fromkeys(tokens))
    return ", ".join(tokens)[:1000]


================================================================================
// Path: ats_parser/sections.py
================================================================================

import re


def split_sections(text: str) -> dict[str, list[str]]:
    SECTION_PATTERNS = {
        "SUMMARY": re.compile(
            r"^(summary|professional summary|profile)\b[:\-–—]?", re.I
        ),
        "EXPERIENCE": re.compile(
            r"^(experience|work (?:history|experience)|employment|professional experience|projects?)\b[:\-–—]?",
            re.I,
        ),
        "EDUCATION": re.compile(
            r"^(education|academic background|studies)\b[:\-–—]?", re.I
        ),
        "SKILLS": re.compile(
            r"^(skills|technical skills|technologies|tooling|competenc(?:y|ies))\b[:\-–—]?",
            re.I,
        ),
        "CERTS": re.compile(r"^(certifications?|licenses?)\b[:\-–—]?", re.I),
        "LANGUAGES": re.compile(r"^(languages?)\b[:\-–—]?", re.I),
        "PROJECTS": re.compile(
            r"^(projects|selected projects|personal projects)\b[:\-–—]?", re.I
        ),
    }
    lines = [l.rstrip() for l in text.splitlines()]
    cur = None
    out = {k: [] for k in SECTION_PATTERNS.keys()}
    out.setdefault("OTHER", [])
    for ln in lines:
        s = re.sub(r"\s+", " ", (ln or "").strip())
        if not s:
            continue
        switched = False
        for key, rx in SECTION_PATTERNS.items():
            if rx.match(s):
                cur = key
                switched = True
                break
        if not switched:
            (out[cur] if cur else out["OTHER"]).append(s)
    return out


================================================================================
// Path: templates/_flash.html
================================================================================

{% if get_flashed_messages(with_categories=true) %}
<style>
    .flash {
        border-left: 4px solid;
    }

    .flash.success {
        border-left-color: #10b981;
    }

    .flash.warn {
        border-left-color: #f59e0b;
    }

    .flash.info {
        border-left-color: #3b82f6;
    }

    .flash.error {
        border-left-color: #ef4444;
    }
</style>

<div style="margin:10px 0">
    {% for cat, msg in get_flashed_messages(with_categories=true) %}
    {% set cls = 'success' if cat=='success' else 'warn' if cat=='warn' else 'info' if cat=='info' else 'error' %}
    <div class="card flash {{ cls }}">{{ msg }}</div>
    {% endfor %}
</div>
{% endif %}

================================================================================
// Path: templates/_theme.html
================================================================================

<style>
    :root {
        --bg: #0a0f1d;
        --bg-soft: #0b1224;
        --surface: #0f172a;
        --surface-2: #111b31;
        --border: #1e293b;
        --text: #e5e7eb;
        --muted: #94a3b8;
        --primary: #3b82f6;
        /* blue */
        --primary-2: #60a5fa;
        --green: #10b981;
        --amber: #f59e0b;
        --red: #ef4444;
        --ring: rgba(59, 130, 246, .45);
        --shadow: 0 10px 30px rgba(0, 0, 0, .35);
    }

    * {
        box-sizing: border-box
    }

    html,
    body {
        height: 100%
    }

    body {
        margin: 0;
        background:
            radial-gradient(1200px 600px at 20% -10%, rgba(59, 130, 246, .12), transparent 60%),
            radial-gradient(1000px 500px at 120% 10%, rgba(16, 185, 129, .10), transparent 60%),
            var(--bg);
        color: var(--text);
        background-repeat: no-repeat, no-repeat, no-repeat, no-repeat, no-repeat;
        background-attachment: fixed, fixed, fixed, fixed, fixed;
        font: 15px/1.5 Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }

    /* Header + Nav */
    header {
        padding: 22px 0;
        background:
            linear-gradient(180deg, rgba(16, 24, 40, .6), rgba(16, 24, 40, 0)),
            linear-gradient(90deg, rgba(59, 130, 246, .18), rgba(59, 130, 246, 0) 40%, rgba(16, 185, 129, .18));
        border-bottom: 1px solid var(--border);
        backdrop-filter: saturate(130%) blur(6px);
    }

    header .container {
        max-width: 1100px;
        margin: 0 auto;
        padding: 0 16px;
        display: flex;
        align-items: center;
        justify-content: space-between
    }

    header h1 {
        margin: 0;
        font-size: 18px;
        letter-spacing: .2px
    }

    nav .btn {
        margin-right: 8px
    }

    /* Layout */
    main {
        max-width: 1100px;
        margin: 24px auto;
        padding: 0 16px
    }

    /* Card */
    .card {
        background: linear-gradient(180deg, var(--surface), var(--surface-2));
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 18px;
        margin: 16px 0;
        box-shadow: var(--shadow);
        transition: transform .15s ease, box-shadow .15s ease, border-color .15s ease;
    }

    .card:hover {
        transform: translateY(-1px);
        border-color: #2a3a55
    }

    /* Upload bar */
    .upload {
        display: flex;
        gap: 12px;
        align-items: center;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 14px 16px;
    }

    .upload input[type=file] {
        flex: 1;
        color: var(--muted)
    }

    .upload button {
        min-width: 160px
    }

    /* Forms */
    label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin: 0 0 6px 2px
    }

    input,
    textarea {
        width: 100%;
        padding: 10px 12px;
        border: 1px solid var(--border);
        border-radius: 10px;
        background: #0b1120;
        color: var(--text);
        outline: none;
        transition: border-color .15s ease, box-shadow .15s ease, background .15s;
    }

    input:focus,
    textarea:focus {
        border-color: var(--primary);
        box-shadow: 0 0 0 4px var(--ring);
        background: #0c1426;
    }

    textarea {
        min-height: 96px;
        resize: vertical
    }

    /* Buttons */
    .btn {
        --btn-bg: #0b1120;
        --btn-bd: var(--border);
        --btn-fg: var(--text);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        padding: 9px 14px;
        border-radius: 10px;
        border: 1px solid var(--btn-bd);
        background: var(--btn-bg);
        color: var(--btn-fg);
        cursor: pointer;
        text-decoration: none;
        transition: transform .12s ease, background .15s, border-color .15s, box-shadow .15s;
    }

    .btn:hover {
        transform: translateY(-1px);
        border-color: #2b3b57
    }

    .btn:active {
        transform: translateY(0)
    }

    .btn.primary {
        --btn-bg: linear-gradient(180deg, var(--primary-2), var(--primary));
        --btn-bd: transparent;
        --btn-fg: #fff;
        box-shadow: 0 6px 18px rgba(59, 130, 246, .25);
    }

    .btn.destructive {
        --btn-bg: #1b0e12;
        --btn-bd: #402227;
        --btn-fg: #fecaca;
    }

    .btn.ghost {
        --btn-bg: transparent;
        --btn-bd: var(--border);
        --btn-fg: var(--text);
    }

    /* Badges / Chips */
    .badge {
        display: inline-block;
        padding: 4px 10px;
        border-radius: 999px;
        background: #16253f;
        color: #b6d4ff;
        border: 1px solid var(--border);
        font-size: 12px
    }

    /* Grid helpers already in your HTML – keep them */
    .grid {
        display: grid;
        grid-template-columns: repeat(12, 1fr);
        gap: 12px
    }

    .col-12 {
        grid-column: span 12
    }

    .col-6 {
        grid-column: span 6
    }

    .col-4 {
        grid-column: span 4
    }

    .col-3 {
        grid-column: span 3
    }

    /* Tables (admin) */
    table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        border: 1px solid var(--border);
        border-radius: 12px;
        overflow: hidden
    }

    thead th {
        font-weight: 600;
        font-size: 12px;
        color: var(--muted);
        background: #0c1426
    }

    th,
    td {
        padding: 10px 12px;
        border-bottom: 1px solid var(--border)
    }

    tbody tr:nth-child(odd) {
        background: #0b1224
    }

    tbody tr:hover {
        background: #0f1a33
    }

    td .btn {
        padding: 6px 10px
    }

    /* Flash banners (uses your existing partial) */
    .flash {
        border-left: 4px solid;
        background: #0d1428;
        padding: 10px 14px;
        border-radius: 10px;
        margin: 8px 0
    }

    .flash.success {
        border-left-color: var(--green);
        background: rgba(16, 185, 129, .12)
    }

    .flash.warn {
        border-left-color: var(--amber);
        background: rgba(245, 158, 11, .12)
    }

    .flash.info {
        border-left-color: var(--primary);
        background: rgba(59, 130, 246, .12)
    }

    .flash.error {
        border-left-color: var(--red);
        background: rgba(239, 68, 68, .12)
    }

    /* Section dividers */
    .section {
        margin-top: 16px;
        padding-top: 16px;
        border-top: 1px dashed var(--border)
    }

    /* Utility */
    .container {
        max-width: 1100px;
        margin: 0 auto;
        padding: 0 16px
    }

    .muted {
        color: var(--muted)
    }
</style>

================================================================================
// Path: templates/admin_candidates.html
================================================================================

<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    {% include "_theme.html" %}
    <title>All Candidates</title>
</head>

<body style="font-family:Inter,system-ui;background:#0b0f1a;color:#e5e7eb">
    <main style="max-width:1100px;margin:40px auto;padding:16px">
        {% include "_flash.html" %}
        <div class="card">
            <h2>All Candidates</h2>
            <table style="width:100%;border-collapse:collapse">
                <thead>
                    <tr>
                        <th style="text-align:left;padding:8px;border-bottom:1px solid #1f2937">ID</th>
                        <th style="text-align:left;padding:8px;border-bottom:1px solid #1f2937">Name</th>
                        <th style="text-align:left;padding:8px;border-bottom:1px solid #1f2937">Email</th>
                        <th style="text-align:left;padding:8px;border-bottom:1px solid #1f2937">Phone</th>
                        <th></th>
                    </tr>
                </thead>
                <tbody>
                    {% for r in rows %}
                    <tr>
                        <td style="padding:8px;border-bottom:1px solid #1f2937">{{ r[0] }}</td>
                        <td style="padding:8px;border-bottom:1px solid #1f2937">{{ r[1] }}</td>
                        <td style="padding:8px;border-bottom:1px solid #1f2937">{{ r[2] }}</td>
                        <td style="padding:8px;border-bottom:1px solid #1f2937">{{ r[3] }}</td>
                        <td style="padding:8px;border-bottom:1px solid #1f2937">
                            <form method="post" action="{{ url_for('admin_delete_candidate', cand_id=r[0]) }}"
                                onsubmit="return confirm('Delete candidate #{{r[0]}}?')">
                                <button class="btn" style="border-color:#ef4444">Delete</button>
                            </form>
                        </td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
            <div style="margin-top:12px">
                <a class="btn" href="{{ url_for('index') }}">Back to app</a>
            </div>
        </div>
    </main>
</body>

</html>

================================================================================
// Path: templates/admin_home.html
================================================================================

<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>Admin</title>
</head>

<body style="font-family:Inter,system-ui;background:#0b0f1a;color:#e5e7eb">
    <main style="max-width:900px;margin:40px auto;padding:16px">
        {% include "_flash.html" %}
        <div class="card">
            <h2>Admin</h2>
            <p>Welcome, {{ user.username }}.</p>
            <div style="display:flex;gap:10px">
                <a class="btn" href="{{ url_for('admin_candidates') }}">See all candidates</a>
                <a class="btn" href="{{ url_for('index') }}">Back to app</a>
            </div>
        </div>
    </main>
</body>

</html>

================================================================================
// Path: templates/auth_login.html
================================================================================

<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    {% include "_theme.html" %}
    <title>Login</title>
</head>

<body style="font-family:Inter,system-ui;background:#0b0f1a;color:#e5e7eb">
    <main style="max-width:420px;margin:40px auto;padding:16px">
        {% include "_flash.html" %}
        <div class="card">
            <h2>Log in</h2>
            <form method="post" action="{{ url_for('login', next=next) }}">
                <label>Username</label><input name="username" required>
                <label>Password</label><input type="password" name="password" required>
                <div style="margin-top:12px;display:flex;gap:8px">
                    <button class="btn primary">Log in</button>
                    <a class="btn" href="{{ url_for('signup') }}">Create account</a>
                    <a class="btn" href="{{ url_for('reset_request') }}">Reset password</a>
                </div>
            </form>
        </div>
    </main>
</body>

</html>

================================================================================
// Path: templates/auth_reset_request.html
================================================================================

<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    {% include "_theme.html" %}
    <title>Reset password</title>
</head>

<body style="font-family:Inter,system-ui;background:#0b0f1a;color:#e5e7eb">
    <main style="max-width:420px;margin:40px auto;padding:16px">
        {% include "_flash.html" %}
        <div class="card">
            <h2>Password reset</h2>
            <p class="muted">Enter your username. A reset token will be generated (demo flow).</p>
            <form method="post">
                <label>Username</label><input name="username" required>
                <div style="margin-top:12px;display:flex;gap:8px">
                    <button class="btn primary">Generate token</button>
                    <a class="btn" href="{{ url_for('login') }}">Back to login</a>
                </div>
            </form>
        </div>
    </main>
</body>

</html>

================================================================================
// Path: templates/auth_reset_set.html
================================================================================

<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    {% include "_theme.html" %}
    <title>Set new password</title>
</head>

<body style="font-family:Inter,system-ui;background:#0b0f1a;color:#e5e7eb">
    <main style="max-width:420px;margin:40px auto;padding:16px">
        {% include "_flash.html" %}
        <div class="card">
            <h2>Choose a new password</h2>
            <form method="post">
                <label>New password</label><input type="password" name="password" required>
                <div style="margin-top:12px;display:flex;gap:8px">
                    <button class="btn primary">Update</button>
                    <a class="btn" href="{{ url_for('login') }}">Cancel</a>
                </div>
            </form>
        </div>
    </main>
</body>

</html>

================================================================================
// Path: templates/auth_signup.html
================================================================================

<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    {% include "_theme.html" %}
    <title>Sign up</title>
</head>

<body style="font-family:Inter,system-ui;background:#0b0f1a;color:#e5e7eb">
    <main style="max-width:420px;margin:40px auto;padding:16px">
        {% include "_flash.html" %}
        <div class="card">
            <h2>Create account</h2>
            <form method="post">
                <label>Username</label><input name="username" required>
                <label>Password</label><input type="password" name="password" required>
                <div style="margin-top:12px;display:flex;gap:8px">
                    <button class="btn primary">Create</button>
                    <a class="btn" href="{{ url_for('login') }}">Back to login</a>
                </div>
            </form>
        </div>
    </main>
</body>

</html>

================================================================================
// Path: templates/index.html
================================================================================

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>ATS Scanner</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root {
      --bg: #0b0f1a;
      --card: #0f1422;
      --muted: #9aa3af;
      --accent: #3b82f6;
      --border: #1f2937;
      --text: #e5e7eb;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
    }

    header {
      padding: 20px;
      background: #0a0f1d;
      border-bottom: 1px solid var(--border);
    }

    header h1 {
      margin: 0;
      font-size: 20px;
    }

    main {
      max-width: 1100px;
      margin: 20px auto;
      padding: 0 16px;
    }

    .upload {
      background: var(--card);
      padding: 16px;
      border-radius: 12px;
      border: 1px solid var(--border);
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .upload input[type=file] {
      flex: 1;
      color: var(--muted);
    }

    .upload button {
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 10px 14px;
      border-radius: 8px;
      cursor: pointer;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 18px;
      margin: 16px 0;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.12);
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 12px;
    }

    .col-12 {
      grid-column: span 12;
    }

    .col-6 {
      grid-column: span 6;
    }

    .col-4 {
      grid-column: span 4;
    }

    .col-3 {
      grid-column: span 3;
    }

    label {
      font-size: 12px;
      color: var(--muted);
      display: block;
      margin-bottom: 6px;
    }

    input,
    textarea {
      width: 100%;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #0b1120;
      color: var(--text);
    }

    textarea {
      min-height: 80px;
      resize: vertical;
    }

    .row {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .badge {
      display: inline-block;
      padding: 4px 10px;
      background: #1f2a44;
      color: #93c5fd;
      border-radius: 999px;
      font-size: 12px;
      margin-right: 6px;
      border: 1px solid var(--border);
    }

    .btn {
      border: 1px solid var(--border);
      background: #0b1120;
      color: var(--text);
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
    }

    .btn.primary {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }

    .section {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px dashed var(--border);
    }

    .muted {
      color: var(--muted);
    }
  </style>
  {% include "_theme.html" %}
</head>

<body>
  <header>
    <div class="container">
      <h1>ATS Scanner — Structured Resume Parser</h1>
    </div>
  </header>
  <main>
    <nav class="card" style="display:flex; gap:12px; align-items:center; justify-content:space-between;">
      <div>
        <a class="btn" href="/">Home</a>
        <a class="btn" href="/admin">Admin</a>
        <a class="btn" href="/admin/candidates">All CVs</a>
      </div>
      <div>
        <a class="btn" href="/logout">Log out</a>
      </div>
    </nav>

    {% include "_flash.html" %}

    <form class="upload" method="POST" enctype="multipart/form-data">
      <input type="file" name="resume" accept=".pdf" required>
      <button type="submit">Upload & Parse</button>
    </form>
    {% for c in candidates %}
    {% set cid = c[0] %}
    {% set name = c[1] %}
    {% set first = c[2] or "" %}
    {% set middle = c[3] or "" %}
    {% set last = c[4] or "" %}
    {% set phone = c[5] or "" %}
    {% set email = c[6] or "" %}
    {% set links = (json.loads(c[7] or "[]")) %}
    {% set edu = json.loads(c[8] or "[]") %}
    {% set exp = json.loads(c[9] or "[]") %}
    {% set skills = c[10] or "" %}



    <div class="card" id="card-{{cid}}">
      <div class="row" style="justify-content:space-between;">
        <h2 style="margin:0">{{ name or "Unnamed Candidate" }}</h2>
        <div><span class="badge">ID #{{cid}}</span></div>
      </div>

      <div class="grid section">
        <div class="col-4">
          <label>First Name</label>
          <input id="first-{{cid}}" value="{{ first }}">
        </div>
        <div class="col-4">
          <label>Middle Name</label>
          <input id="middle-{{cid}}" value="{{ middle }}">
        </div>
        <div class="col-4">
          <label>Last Name</label>
          <input id="last-{{cid}}" value="{{ last }}">
        </div>

        <div class="col-6">
          <label>Phone</label>
          <input id="phone-{{cid}}" value="{{ phone }}">
        </div>
        <div class="col-6">
          <label>Email</label>
          <input id="email-{{cid}}" value="{{ email }}">
        </div>

        <div class="col-12">
          <label>Links</label>
          <div id="links-{{cid}}">
            {% if links|length == 0 %}
            <input id="link-{{cid}}-0" value="">
            {% else %}
            {% for u in links %}
            <input id="link-{{cid}}-{{loop.index0}}" value="{{ u }}">
            {% endfor %}
            {% endif %}
          </div>
        </div>
      </div>


      <div class="section">
        <h3>Experience</h3>
        {% if exp|length == 0 %}<p class="muted">No experience parsed.</p>{% endif %}
        {% for e in exp %}
        <div class="grid" style="margin-bottom:12px;" data-exp="{{loop.index0}}">
          <div class="col-4">
            <label>Position</label>
            <input id="exp-{{cid}}-{{loop.index0}}-position" value="{{ e.get('position','') }}">
          </div>
          <div class="col-4">
            <label>Company</label>
            <input id="exp-{{cid}}-{{loop.index0}}-company_name"
              value="{{ e.get('company_name', e.get('company','')) }}">
          </div>
          <div class="col-4">
            <label>Location</label>
            <input id="exp-{{cid}}-{{loop.index0}}-location" value="{{ e.get('location','') }}">
          </div>
          <div class="col-4">
            <label>Start Date</label>
            <input id="exp-{{cid}}-{{loop.index0}}-start_date" value="{{ e.get('start_date','') }}">
          </div>
          <div class="col-4">
            <label>End Date</label>
            <input id="exp-{{cid}}-{{loop.index0}}-end_date" value="{{ e.get('end_date','') }}">
          </div>
          <div class="col-4">
            <label>Duration (months)</label>
            <input id="exp-{{cid}}-{{loop.index0}}-duration_months" value="{{ e.get('duration_months','') }}">
          </div>
          <div class="col-12">
            <label>Role Description</label>
            <textarea id="exp-{{cid}}-{{loop.index0}}-description">{{ e.get('description','') }}</textarea>
          </div>
        </div>
        {% endfor %}
      </div>

      <div class="section">
        <h3>Education</h3>
        {% set edu_list = edu if edu|length > 0 else [
        {'level':'','field':'','school_name':'','location':'','start_year':'','end_year':''} ] %}
        {% for ed in edu_list %}
        <div class="grid" style="margin-bottom:12px;" data-edu="{{loop.index0}}">
          <div class="col-4">
            <label>Level</label>
            <input id="edu-{{cid}}-{{loop.index0}}-level" value="{{ ed.get('level', ed.get('degree','')) }}">
          </div>
          <div class="col-4">
            <label>Field</label>
            <input id="edu-{{cid}}-{{loop.index0}}-field" value="{{ ed.get('field','') }}">
          </div>
          <div class="col-4">
            <label>School</label>
            <input id="edu-{{cid}}-{{loop.index0}}-school_name" value="{{ ed.get('school_name', ed.get('school','')) }}"
              readonly>
          </div>
          <div class="col-6">
            <label>Location</label>
            <input id="edu-{{cid}}-{{loop.index0}}-location" value="{{ ed.get('location','') }}">
          </div>
          <div class="col-3">
            <label>Start Year</label>
            <input id="edu-{{cid}}-{{loop.index0}}-start_year" value="{{ ed.get('start_year','') }}">
          </div>
          <div class="col-3">
            <label>End Year</label>
            <input id="edu-{{cid}}-{{loop.index0}}-end_year" value="{{ ed.get('end_year','') }}">
          </div>
        </div>
        {% endfor %}
      </div>
      <div class="grid section">
        <div class="col-12">
          <label>Skills (technical; CSV)</label>
          <textarea id="skills-{{cid}}">{{ skills }}</textarea>
        </div>
      </div>
    </div>
    {% endfor %}
    <div class="card" style="display:flex; justify-content:flex-end;">
      <button type="button" class="btn primary" id="save-all">Save All Changes</button>
    </div>
  </main>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      document.querySelectorAll('input[readonly], textarea[readonly]')
        .forEach(el => el.removeAttribute('readonly'));
      const btn = document.getElementById('save-all');
      if (btn) btn.addEventListener('click', saveAllCandidates);
    });

    function collectLinks(cid) {
      const wrap = document.getElementById(`links-${cid}`);
      const arr = [];
      if (!wrap) return arr;
      wrap.querySelectorAll('input[id^="link-"]').forEach(el => {
        const v = (el.value || "").trim();
        if (v) arr.push(v);
      });
      return arr;
    }

    function collectList(prefix, cid, attrNames) {
      const card = document.getElementById(`card-${cid}`);
      const blocks = [];
      if (!card) return blocks;
      card.querySelectorAll(`[data-${prefix}]`).forEach(block => {
        const idx = block.getAttribute(`data-${prefix}`);
        const obj = {};
        attrNames.forEach(name => {
          const el = document.getElementById(`${prefix}-${cid}-${idx}-${name}`);
          obj[name] = el ? el.value : "";
        });
        blocks.push(obj);
      });
      return blocks;
    }

    function collectCandidate(cid) {
      const first = (document.getElementById(`first-${cid}`)?.value || "");
      const middle = (document.getElementById(`middle-${cid}`)?.value || "");
      const last = (document.getElementById(`last-${cid}`)?.value || "");
      const phone = (document.getElementById(`phone-${cid}`)?.value || "");
      const email = (document.getElementById(`email-${cid}`)?.value || "");
      const links = collectLinks(cid);
      const name = [first, middle, last].filter(Boolean).join(' ').trim();

      const experience = collectList('exp', cid, [
        'position', 'company_name', 'location', 'start_date', 'end_date', 'duration_months', 'description'
      ]).map(e => {
        e.duration_months = e.duration_months ? parseInt(e.duration_months, 10) : null;
        e.skills_used_tech = e.skills_used_tech || [];
        e.skills_used_soft = e.skills_used_soft || [];
        return e;
      });

      const education = collectList('edu', cid, [
        'level', 'field', 'school_name', 'location', 'start_year', 'end_year'
      ]);

      const skills = (document.getElementById(`skills-${cid}`)?.value || "");
      const languages = "";

      return {
        name, first_name: first, middle_name: middle, last_name: last,
        phone, email, links, education, experience, skills, languages
      };
    }

    async function saveAllCandidates() {
      const btn = document.getElementById('save-all');
      if (btn) { btn.disabled = true; btn.textContent = 'Saving...'; }
      const cards = document.querySelectorAll('.card[id^="card-"]');
      let ok = 0, fail = 0;

      for (const card of cards) {
        const cid = parseInt(card.id.replace('card-', ''), 10);
        const payload = collectCandidate(cid);
        try {
          const res = await fetch(`/update/${cid}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          if (res.ok) ok++; else fail++;
        } catch {
          fail++;
        }
      }

      if (btn) {
        btn.disabled = false;
        btn.textContent = 'Save All Changes';
      }
      alert(`Saved ${ok} candidate(s)` + (fail ? `, ${fail} failed` : ''));
    }
  </script>

</body>

</html>


// Summary: wrote 23 files, skipped 55387 files.
